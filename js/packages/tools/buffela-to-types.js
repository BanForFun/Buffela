#!/usr/bin/env node

const process = require('node:process')

const {
    Printer,
    readSchema,
    getFileOutputStream
} = require('@buffela/tools-common')

const { parseSchema } = require('@buffela/parser')

const debugMode = true

if (process.argv.length < 3 || process.argv.length > 4) {
    console.error("Usage: node buffela-to-types.js BUFFELA_FILE [OUTPUT_FILE_OR_DIRECTORY]")
    process.exit(1)
}

const serializationEnabled = true
const deserializationEnabled = true

const inputPath = process.argv[2]
const inputFile = readSchema(inputPath)

/**
 * @type {import('@buffela/parser').Schema}
 */
const schema = parseSchema(inputFile.schema)

const outputPath = process.argv[3]
const defaultExtension = debugMode ? ".ts" : ".d.ts"
const outputStream = getFileOutputStream(outputPath, inputFile.name + defaultExtension)
const printer = new Printer(outputStream)

const nativeTypes = {
    "UByte":            "number",
    "UShort":           "number",
    "Int":              "number",
    "String":           "string",
    "Boolean":          "boolean",
    "Byte":             "number",
    "Short":            "number",
    "Long":             "BigInt",
    "Float":            "number",
    "Double":           "number",
    "UInt":             "number",
    "ULong":            "BigInt",
    "UByteArray":       "Uint8Array",
    "UShortArray":      "Uint16Array",
    "UIntArray":        "Uint32Array",
    "ULongArray":       "BigUint64Array",
    "BooleanArray":     "Uint8ClampedArray",
    "ByteArray":        "Int8Array",
    "ShortArray":       "Int16Array",
    "IntArray":         "Int32Array",
    "LongArray":        "BigInt64Array",
    "FloatArray":       "Float32Array",
    "DoubleArray":      "Float64Array",
    "Buffer":           "Buffer",
}

printer.line("// Auto-generated by buffela-to-types, DO NOT MODIFY")

const typeExtensions = [], primitiveExtensions = []

if (serializationEnabled) {
    printer.line('import type { Serializable as serializable, Serializer as serializer } from "@buffela/serializer"')
    typeExtensions.push('serializable<T>')
    primitiveExtensions.push('serializer<T>')
}

if (deserializationEnabled) {
    printer.line('import type { Deserializable as deserializable, Deserializer as deserializer } from "@buffela/deserializer"')
    typeExtensions.push('deserializable<T>')
    primitiveExtensions.push('deserializer<T>')
}

for (const type in schema.primitives) {
    if (type in nativeTypes) continue;
    printer.line(`import type ${type} from "./primitives/${type}"`)
}

printer.line()
printer.line('declare const id: unique symbol')

function combineExtensions(extensions) {
    if (!extensions.length) return '{}'
    return extensions.join(' & ')
}

printer.line()
printer.line(`type type<T> = Partial<${combineExtensions(typeExtensions)}>`)
printer.line(`type primitive<T> = Partial<${combineExtensions(primitiveExtensions)}>`)

/**
 * @param {import('@buffela/parser').ObjectType} objectType
 * @param {string} name
 * @param {...string} path
 */
function printObjectSubTypeInterface(objectType, name, ...path) {
    const fullPath = [...path, name]

    if (objectType.isLeaf) {
        printer.line(`readonly ${name}: { [id]: "${fullPath.join('.')}" }`)
    } else {
        printer.blockStart(`readonly ${name}: {`)

        for (
            /** @type {import('@buffela/parser').TypeName} */
            const subtypeName in objectType
        ) {
            printObjectSubTypeInterface(objectType[subtypeName], subtypeName, ...fullPath)
        }

        printer.blockEnd('}')
    }
}

/**
 * @param {import('@buffela/parser').ObjectType} objectType
 * @param {string} name
 */
function printObjectTypeInterface(objectType, name) {
    printer.blockStart(`type _${name} = {`)

    for (
        /** @type {import('@buffela/parser').TypeName} */
        const subtypeName in objectType
    ) {
        printObjectSubTypeInterface(objectType[subtypeName], subtypeName, name)
    }

    printer.blockEnd('}')
}

/**
 * @param {import('@buffela/parser').EnumType} enumType
 * @param {string} name
 */
function printEnumTypeInterface(enumType, name) {
    printer.blockStart(`type _${name} = {`)

    for (
        /** @type {import('@buffela/parser').EnumValue} */
        const value in enumType
    ) {
        printer.line(`readonly ${value}: { [id]: "${name}.${value}" }`)
    }

    printer.blockEnd('}')
}

for (
    /** @type {import('@buffela/parser').TypeName} */
    const name in schema
) {
    const type = schema[name]

    if (type.kind === "enum") {
        printEnumTypeInterface(type, name)
    } else if (type.kind === "object") {
        printObjectTypeInterface(type, name)
    }
}

/**
 *
 * @param {...string} path
 * @returns {string}
 */
function typeOf(...path) {
    const [root, ...rest] = path;
    return `_${root}${rest.map(n => `["${n}"]`).join("")}`
}

/**
 *
 * @param {import('@buffela/parser').FieldType} field
 * @returns {string}
 */
function nativeType(field) {
    const { name, dimensions } = field;
    const arraySuffix = dimensions.map(() => "[]").join("")

    return nativeTypes[name] ?? name + arraySuffix
}

/**
 *
 * @param {import('@buffela/parser').ObjectType} objectType
 * @param {string[]} path
 * @returns {boolean} isLeaf
 */
function printObjectType(objectType, path) {
    if (!objectType.isRoot)
        printer.line(`_type: ${typeOf(...path)},`)

    for (const fieldName in objectType.fields) {
        const field = objectType.fields[fieldName];
        printer.line(`${fieldName}: ${nativeType(field)},`)
    }

    if (objectType.isLeaf) return true;

    printer.blockEndStart('} & (')

    const subtypes = Object.keys(objectType)
    for (let i = 0; i < subtypes.length; i++) {
        if (i === 0) printer.blockStart('{')

        /** @type {import('@buffela/parser').TypeName} */
        const subtypeName = subtypes[i]

        const subtype = objectType[subtypeName]
        const isLeaf = printObjectType(subtype, path.concat(subtypeName))

        if (i < subtypes.length - 1) {
            printer.blockEndStart(isLeaf ? '} | {' : ') | {')
        } else {
            printer.blockEnd(isLeaf ? '}' : ')')
        }
    }

    return false;
}

for (
    /** @type {import('@buffela/parser').TypeName} */
    const name in schema
) {
    const type = schema[name]

    if (type.kind === "enum") {
        printer.line()
        printer.line(`export type ${name} = _${name}[keyof _${name}]`)
    } else if (type.kind === "object") {
        printer.blockStart(`export type ${name} = {`)
        const isLeaf = printObjectType(type, [name])
        printer.blockEnd(isLeaf ? '}' : ')')
    }
}


printer.blockStart(`type schema = {`)

for (const name in schema) {
    printer.line(`readonly ${name}: _${name} & type<${name}>`)
}

printer.blockStart('primitives: {')
for (const name in schema.primitives) {
    if (name in nativeTypes) continue;
    printer.line(`${name}?: primitive<${name}>`)
}
printer.blockEnd('}')

printer.blockEnd('}')

printer.line()
printer.line("export default schema")
