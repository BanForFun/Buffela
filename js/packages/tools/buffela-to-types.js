#!/usr/bin/env node

const process = require('node:process')

const {
    Printer,
    readSchema,
    getFileOutputStream
} = require('@buffela/tools-common')

const { parseSchema } = require('@buffela/parser')

if (process.argv.length < 3 || process.argv.length > 4) {
    console.error("Usage: node buffela-to-types.js BUFFELA_FILE [OUTPUT_FILE_OR_DIRECTORY]")
    process.exit(1)
}

const inputPath = process.argv[2]
const inputFile = readSchema(inputPath)
const schema = parseSchema(inputFile.schema)

const outputPath = process.argv[3]
const outputStream = getFileOutputStream(outputPath, inputFile.name + ".d.ts")
const printer = new Printer(outputStream)

const nativeTypes = {
    "UByte":            "number",
    "UShort":           "number",
    "Int":              "number",
    "String":           "string",
    "Boolean":          "boolean",
    "Byte":             "number",
    "Short":            "number",
    "Long":             "BigInt",
    "Float":            "number",
    "Double":           "number",
    "UInt":             "number",
    "ULong":            "BigInt",
    "UByteArray":       "Uint8Array",
    "UShortArray":      "Uint16Array",
    "UIntArray":        "Uint32Array",
    "ULongArray":       "BigUint64Array",
    "BooleanArray":     "Uint8ClampedArray",
    "ByteArray":        "Int8Array",
    "ShortArray":       "Int16Array",
    "IntArray":         "Int32Array",
    "LongArray":        "BigInt64Array",
    "FloatArray":       "Float32Array",
    "DoubleArray":      "Float64Array",
    "Buffer":           "Buffer",
}

printer.line("// Auto-generated by buffela-to-types, DO NOT MODIFY")

printer.line('import type _schema from "@buffela/parser/types/Schema"')
printer.line('import type _primitive from "@buffela/parser/types/Primitive"')

for (const type in schema.primitives) {
    if (type in nativeTypes) continue;
    printer.line(`import type ${type} from "./primitives/${type}"`)
}

/**
 * @param {import('@buffela/parser/types/ObjectType').default} objectType
 * @param {string} name
 */
function printObjectSubTypeInterface(objectType, name) {
    if (objectType.isLeaf) {
        printer.line(`readonly ${name}: unique symbol`)
    } else {
        printer.blockStart(`readonly ${name}: {`)

        for (
            /** @type {import('@buffela/parser/types/Type').TypeName} */
            const subtypeName in objectType
        ) {
            printObjectSubTypeInterface(objectType[subtypeName], subtypeName)
        }

        printer.blockEnd('}')
    }
}

/**
 * @param {import('@buffela/parser/types/ObjectType').default} objectType
 * @param {string} name
 */
function printObjectTypeInterface(objectType, name) {
    printer.blockStart(`interface _${name} {`)

    for (
        /** @type {import('@buffela/parser/types/Type').TypeName} */
        const subtypeName in objectType
    ) {
        printObjectSubTypeInterface(objectType[subtypeName], subtypeName)
    }

    printer.blockEnd('}')
}

/**
 * @param {import('@buffela/parser/types/EnumType').default} enumType
 * @param {string} name
 */
function printEnumTypeInterface(enumType, name) {
    printer.blockStart(`interface _${name} {`)

    for (
        /** @type {import('@buffela/parser/types/EnumType').EnumValue} */
        const value in enumType
    ) {
        printer.line(`readonly ${value}: unique symbol`)
    }

    printer.blockEnd('}')
}

for (
    /** @type {import('@buffela/parser/types/Type').TypeName} */
    const name in schema
) {
    const type = schema[name]

    if (type.kind === "enum") {
        printEnumTypeInterface(type, name)
    } else if (type.kind === "object") {
        printObjectTypeInterface(type, name)
    }
}

/**
 *
 * @param {...string} path
 * @returns {string}
 */
function typeOf(...path) {
    const [root, ...rest] = path;
    return `_${root}${rest.map(n => `["${n}"]`).join("")}`
}

/**
 *
 * @param {import('@buffela/parser/types/FieldType').default} field
 * @returns {string}
 */
function nativeType(field) {
    const { name, dimensions } = field;
    const arraySuffix = dimensions.map(() => "[]").join("")

    return nativeTypes[name] ?? name + arraySuffix
}

/**
 *
 * @param {import('@buffela/parser/types/ObjectType').default} objectType
 * @param {string[]} path
 * @returns {boolean} isLeaf
 */
function printObjectType(objectType, path) {
    if (!objectType.isRoot)
        printer.line(`_type: ${typeOf(...path)},`)

    for (const fieldName in objectType.fields) {
        const field = objectType.fields[fieldName];
        printer.line(`${fieldName}: ${nativeType(field)},`)
    }

    if (objectType.isLeaf) return true;

    printer.blockEndStart('} & (')

    const subtypes = Object.keys(objectType)
    for (let i = 0; i < subtypes.length; i++) {
        if (i === 0) printer.blockStart('{')

        /** @type {import('@buffela/parser/types/Type').TypeName} */
        const subtypeName = subtypes[i]

        const subtype = objectType[subtypeName]
        const isLeaf = printObjectType(subtype, path.concat(subtypeName))

        if (i < subtypes.length - 1) {
            printer.blockEndStart(isLeaf ? '} | {' : ') | {')
        } else {
            printer.blockEnd(isLeaf ? '}' : ')')
        }
    }

    return false;
}

for (
    /** @type {import('@buffela/parser/types/Type').TypeName} */
    const name in schema
) {
    const type = schema[name]

    if (type.kind === "enum") {
        printer.line()
        printer.line(`export type ${name} = _${name}[keyof _${name}]`)
    } else if (type.kind === "object") {
        printer.blockStart(`export type ${name} = {`)
        const isLeaf = printObjectType(type, [name])
        printer.blockEnd(isLeaf ? '}' : ')')
    }
}


printer.blockStart(`type schema = _schema & {`)

for (const name in schema) {
    printer.line(`readonly ${name}: _primitive<${name}> & _${name}`)
}

printer.blockEnd('}')

printer.line()
printer.line("export default schema")
